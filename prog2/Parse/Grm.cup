package Parse;

<<<<<<< HEAD
action code {:
  // chamada do pretty-printer
  // public Absyn.Print p = new Absyn.Print(System.out);

  static Symbol.Symbol sym(String s) {
    return Symbol.Symbol.symbol(s);
  }
:};

parser code  {: 
  public Absyn.Exp parseResult;
=======
action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
>>>>>>> 85ff09edfcf60b5eb296046c0481328fe0807531
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

<<<<<<< HEAD
  public void report_error(String message, 
         java_cup.runtime.Symbol info) {
=======
  public void report_error(String message, java_cup.runtime.Symbol info) {
>>>>>>> 85ff09edfcf60b5eb296046c0481328fe0807531
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
<<<<<<< HEAD
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
  LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
  TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
  ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
  LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;
  
non terminal Absyn.Exp          exp;
non terminal Absyn.Var          var;
non terminal Absyn.ExpList      expList;
non terminal Absyn.FieldVar     fieldVar;
non terminal Absyn.SubscriptVar subscriptVar;
non terminal Absyn.TypeDec      typeDec,optTypes;
non terminal Absyn.FunctionDec  functionDec, optFunctions;
non terminal Absyn.Dec          dec;
non terminal Absyn.DecList      decList;
non terminal Absyn.Ty           type;
non terminal Absyn.NameTy       nameType;
non terminal Absyn.ExpList      arguments, optArguments, sequence, seqTail;
non terminal Absyn.FieldList    fields, optFields;
non terminal Absyn.FieldExpList fieldExps, optFieldExps;
non terminal empty; 

precedence nonassoc THEN;
precedence nonassoc ELSE;
precedence nonassoc ASSIGN;
precedence left     OR;
precedence left     AND;
precedence nonassoc EQ, NEQ, LT, LE, GT, GE;
precedence left     PLUS, MINUS;
precedence left     TIMES, DIVIDE;

start with exp;

exp   ::= error:e
    {: RESULT = new Absyn.SeqExp(eleft, null); :}
    | var:v
    {: RESULT = new Absyn.VarExp(vleft, v); :}
    | NIL:nil
    {: RESULT = new Absyn.NilExp(nilleft); :}
    | INT:i
    {:RESULT = new Absyn.IntExp(ileft,i.intValue()); :}
    | STRING: s
    {:RESULT = new Absyn.StringExp(sleft, (String)(s)); :}
    | ID:f LPAREN:lp arguments:args RPAREN
    {:RESULT = new Absyn.CallExp(lpleft, sym(f), args); :}
    | exp:e1 AND:op exp:e2
    {:RESULT = new Absyn.IfExp(opleft,e1,e2,new Absyn.IntExp(opleft,0)); :} 
    | exp:e1 OR:op exp:e2
    {:RESULT = new Absyn.IfExp(opleft,e1,new Absyn.IntExp(opleft,1),e2); :}
    | exp:e1 PLUS:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,0,e2); :} 
    | exp:e1 MINUS:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,1,e2); :} 
    | exp:e1 TIMES:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,2,e2); :} 
    | exp:e1 DIVIDE:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,3,e2); :} 
    | exp:e1 EQ:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,4,e2); :} 
    | exp:e1 NEQ:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,5,e2); :} 
    | exp:e1 LT:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,6,e2); :} 
    | exp:e1 LE:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,7,e2); :} 
    | exp:e1 GT:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,8,e2); :} 
    | exp:e1 GE:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,9,e2); :} 
    | MINUS:op exp:e
    {:RESULT = new Absyn.OpExp(opleft,new Absyn.IntExp(opleft,0),1,e); :}
    | ID:type_id LBRACE:lbrace fieldExps:fld RBRACE
    {:RESULT = new Absyn.RecordExp(lbraceleft, sym(type_id), fld); :}
    | var:v ASSIGN:ass exp:e
    {:RESULT = new Absyn.AssignExp(assleft,v,e);:}  
    | IF exp:e1 THEN:the exp:e2
    {:RESULT = new Absyn.IfExp(theleft,e1,e2);:}      
    | IF:i exp:e1 THEN exp:e2 ELSE exp:e3
    {:RESULT = new Absyn.IfExp(ileft,e1,e2,e3);:}
    | WHILE:w exp:e1 DO exp:e2
    {: RESULT = new Absyn.WhileExp(wleft, e1, e2); :}
    | FOR:f ID:id ASSIGN:ass exp:e1 TO exp:e2 DO exp:e3
    {: RESULT = new Absyn.ForExp(fleft, new Absyn.VarDec(assleft, sym(id), null, e1), e2, e3);:} 
    | BREAK:b
    {: RESULT = new Absyn.BreakExp(bleft); :}
    | LET decList:decs IN:in expList:ex END
    {: RESULT = new Absyn.LetExp(inleft, decs,new Absyn.SeqExp(exleft,ex)); :}
    | ID:id LBRACK:lbrack exp:e1 RBRACK OF exp:e2
    {: RESULT = new Absyn.ArrayExp(lbrackleft, sym(id),e1,e2);:}
    | LPAREN:lp expList:es RPAREN
    {: RESULT = new Absyn.SeqExp(lpleft,es); :}
    ;

expList ::= empty
    |   exp:e
    {:RESULT = new Absyn.ExpList(e,null);:}
    |   sequence:seq
    {:RESULT = seq;:}
    ;
    
var ::= ID:id
    {: RESULT = new Absyn.SimpleVar(idleft, sym(id)); :}
    | fieldVar:fl
    {: RESULT = fl; :}
    | subscriptVar:sub
    {: RESULT = sub; :}
    ;
    
fieldVar ::= var:n 
    DOT:s ID:id
    {: RESULT = new Absyn.FieldVar(sleft,n,sym(id)); :}
    ;
    
subscriptVar ::= ID:id
    LBRACK:lbrack exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,new Absyn.SimpleVar(idleft,sym(id)),e); :}
    | fieldVar:fl LBRACK:lbrack exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,fl,e); :}
    | subscriptVar:sub LBRACK:lbrack exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,sub,e); :}
    ;   

arguments ::=
    | exp:e optArguments:args
    {: RESULT = new Absyn.ExpList(e,args); :} 
    ;

optArguments ::= error
    |
    {: RESULT = null; :}
    | COMMA exp:e optArguments:args
    {: RESULT = new Absyn.ExpList(e,args); :}
    ;

fieldExps ::= error
    |
    | ID:id EQ:eq exp:e optFieldExps:fld
    {: RESULT = new Absyn.FieldExpList(eqleft,sym(id),e,fld); :}
    ;
    
optFieldExps ::= error
    |
    | COMMA:com ID:id EQ exp:e optFieldExps:fld
    {: RESULT = new Absyn.FieldExpList(comleft,sym(id),e,fld); :}
    ;

empty ::= ;

sequence ::= exp:e SEMICOLON seqTail:s
    {: RESULT = new Absyn.ExpList(e,s); :}
    ;

seqTail ::= exp:e
    {: RESULT = new Absyn.ExpList(e,null); :}
    | sequence:s
    {: RESULT = s; :}
    ;

decList ::= dec:d
    {: RESULT = new Absyn.DecList(d,null); :}
    | dec:d decList:ds
    {: RESULT = new Absyn.DecList(d,ds); :}
    ;
    
dec   ::= error
    | functionDec:f
    {: RESULT = f;:}
    | VAR:va ID:id nameType:nt ASSIGN exp:e
    {: RESULT = new Absyn.VarDec(valeft,sym(id),nt,e); :}
    | typeDec:t
    {: RESULT = t; :}
    ;

functionDec ::= 
    FUNCTION:fu ID:id LPAREN fields:fld RPAREN nameType:Nt EQ exp:e optFunctions:f
    {: RESULT = new Absyn.FunctionDec(fuleft,sym(id),fld,Nt,e,f); :}
    ;
    
optFunctions ::=
    
    | functionDec:fu
    {: RESULT = fu; :}
    ;


fields ::= 
    error
    |
    | ID:id1 COLON:col ID:id2 optFields:fld
    {: RESULT = new Absyn.FieldList(colleft,sym(id1),sym(id2),fld); :}
    ;
    
optFields ::= 
    error
    |
    | COMMA:com ID:id1 COLON ID:id2 optFields:fld
    {: RESULT = new Absyn.FieldList(comleft,sym(id1),sym(id2),fld); :}
    ;
    
nameType ::= 
    error
    |
    | COLON:co ID:id
    {:RESULT = new Absyn.NameTy(coleft,sym(id)); :}
    ;

typeDec ::= 
    TYPE:ty1 ID:id EQ:eq type:ty2 optTypes:ty3
    {:RESULT = new Absyn.TypeDec(ty1left,sym(id),ty2,ty3); :}
    ;

optTypes ::=

    | typeDec:ty
    {: RESULT = ty; :} 
    ;
  
type ::=  
    ID:id
    {:RESULT = new Absyn.NameTy(idleft,sym(id)); :} 
    | LBRACE:lbrace fields:fld RBRACE
    {: RESULT = new Absyn.RecordTy(lbraceleft,fld); :}
    | ARRAY:arr OF ID:id
    {: RESULT = new Absyn.ArrayTy(arrleft,sym(id)); :}
    ;
=======
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK, 
	LBRACE, RBRACE, DOT, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE, 
	GT, GE, AND, OR, ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO,
	DO, LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;

non terminal Absyn.Exp          Exp;
non terminal Absyn.Var          Var;

start with Exp;

Exp ::= error:e
	  {: RESULT = new Absyn.SeqExp(eleft, null); :}
	| Var:v
	  {: RESULT = new Absyn.VarExp(vleft, v); :}
	;

Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	;
>>>>>>> 85ff09edfcf60b5eb296046c0481328fe0807531
