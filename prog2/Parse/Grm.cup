package Parse;

action code {: static Symbol.Symbol sym(String s) {
    return Symbol.Symbol.symbol(s);
  }
:};

parser code  {: 
  public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
         java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
  LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
  TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
  ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
  LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;
  
non terminal Absyn.Exp              Exp;
non terminal Absyn.Var              Var;
non terminal Absyn.ExpList          ExpList;
non terminal Absyn.FieldVar         FieldVar;
non terminal Absyn.SubscriptVar     SubscriptVar;
non terminal Absyn.TypeDec          TypeDec,OptTypes;
non terminal Absyn.FunctionDec      FunctionDec, OptFunctions;
non terminal Absyn.Dec              Dec;
non terminal Absyn.DecList          DecList;
non terminal Absyn.Ty               Type;
non terminal Absyn.NameTy           NameType;
non terminal Absyn.ExpList          Arguments, OptArguments, Sequence, SeqTail;
non terminal Absyn.FieldList        Fields, OptFields;
non terminal Absyn.FieldExpList     FieldExps, OptFieldExps;
non terminal empty; 

precedence nonassoc THEN;
precedence nonassoc ELSE;
precedence nonassoc ASSIGN;
precedence left     OR;
precedence left     AND;
precedence nonassoc EQ, NEQ, LT, LE, GT, GE;
precedence left     PLUS, MINUS;
precedence left     TIMES, DIVIDE;

start with Exp;

Exp   ::= error:e
    {: RESULT = new Absyn.SeqExp(eleft, null); :}
    | Var:v
    {: RESULT = new Absyn.VarExp(vleft, v); :}
    | NIL:nil
    {: RESULT = new Absyn.NilExp(nilleft); :}
    | INT:i
    {:RESULT = new Absyn.IntExp(ileft,i.intValue()); :}
    | STRING: s
    {:RESULT = new Absyn.StringExp(sleft, (String)(s)); :}
    | ID:f LPAREN:lp Arguments:args RPAREN
    {:RESULT = new Absyn.CallExp(lpleft, sym(f), args); :}
    | Exp:e1 AND:op Exp:e2
    {:RESULT = new Absyn.IfExp(opleft,e1,e2,new Absyn.IntExp(opleft,0)); :} 
    | Exp:e1 OR:op Exp:e2
    {:RESULT = new Absyn.IfExp(opleft,e1,new Absyn.IntExp(opleft,1),e2); :}
    | Exp:e1 PLUS:op Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,0,e2); :} 
    | Exp:e1 MINUS:op Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,1,e2); :} 
    | Exp:e1 TIMES:op Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,2,e2); :} 
    | Exp:e1 DIVIDE:op Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,3,e2); :} 
    | Exp:e1 EQ:op  Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,4,e2); :} 
    | Exp:e1 NEQ:op Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,5,e2); :} 
    | Exp:e1 LT:op  Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,6,e2); :} 
    | Exp:e1 LE:op  Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,7,e2); :} 
    | Exp:e1 GT:op  Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,8,e2); :} 
    | Exp:e1 GE:op  Exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,9,e2); :} 
    | MINUS:op Exp:e
    {:RESULT = new Absyn.OpExp(opleft,new Absyn.IntExp(opleft,0),1,e); :}
    | ID:type_id LBRACE:lbrace FieldExps:fld RBRACE
    {:RESULT = new Absyn.RecordExp(lbraceleft, sym(type_id), fld); :}
    | Var:v ASSIGN:ass Exp:e
    {:RESULT = new Absyn.AssignExp(assleft,v,e);:}  
    | IF Exp:e1 THEN:the Exp:e2
    {:RESULT = new Absyn.IfExp(theleft,e1,e2);:}      
    | IF:i Exp:e1 THEN Exp:e2 ELSE Exp:e3
    {:RESULT = new Absyn.IfExp(ileft,e1,e2,e3);:}
    | WHILE:w Exp:e1 DO Exp:e2
    {: RESULT = new Absyn.WhileExp(wleft, e1, e2); :}
    | FOR:f ID:id ASSIGN:ass Exp:e1 TO Exp:e2 DO Exp:e3
    {: RESULT = new Absyn.ForExp(fleft, new Absyn.VarDec(assleft, sym(id), null, e1), e2, e3);:} 
    | BREAK:b
    {: RESULT = new Absyn.BreakExp(bleft); :}
    | LET DecList:decs IN:in ExpList:ex END
    {: RESULT = new Absyn.LetExp(inleft, decs,new Absyn.SeqExp(exleft,ex)); :}
    | ID:id LBRACK:lbrack Exp:e1 RBRACK OF Exp:e2
    {: RESULT = new Absyn.ArrayExp(lbrackleft, sym(id),e1,e2);:}
    | LPAREN:lp ExpList:es RPAREN
    {: RESULT = new Absyn.SeqExp(lpleft,es); :}
    ;

ExpList ::= empty
    |   Exp:e
    {:RESULT = new Absyn.ExpList(e,null);:}
    |   Sequence:seq
    {:RESULT = seq;:}
    ;
    
Var ::= ID:id
    {: RESULT = new Absyn.SimpleVar(idleft, sym(id)); :}
    | FieldVar:fl
    {: RESULT = fl; :}
    | SubscriptVar:sub
    {: RESULT = sub; :}
    ;
    
FieldVar ::= Var:n 
    DOT:s ID:id
    {: RESULT = new Absyn.FieldVar(sleft,n,sym(id)); :}
    ;
    
SubscriptVar ::= ID:id
    LBRACK:lbrack Exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,new Absyn.SimpleVar(idleft,sym(id)),e); :}
    | FieldVar:fl LBRACK:lbrack Exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,fl,e); :}
    | SubscriptVar:sub LBRACK:lbrack Exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,sub,e); :}
    ;   

Arguments ::=
    | Exp:e OptArguments:args
    {: RESULT = new Absyn.ExpList(e,args); :} 
    ;

OptArguments ::= error
    |
    {: RESULT = null; :}
    | COMMA Exp:e OptArguments:args
    {: RESULT = new Absyn.ExpList(e,args); :}
    ;

FieldExps ::= error
    |
    | ID:id EQ:eq Exp:e OptFieldExps:fld
    {: RESULT = new Absyn.FieldExpList(eqleft,sym(id),e,fld); :}
    ;
    
OptFieldExps ::= error
    |
    | COMMA:com ID:id EQ Exp:e OptFieldExps:fld
    {: RESULT = new Absyn.FieldExpList(comleft,sym(id),e,fld); :}
    ;

empty ::= ;

Sequence ::= Exp:e SEMICOLON SeqTail:s
    {: RESULT = new Absyn.ExpList(e,s); :}
    ;

SeqTail ::= Exp:e
    {: RESULT = new Absyn.ExpList(e,null); :}
    | Sequence:s
    {: RESULT = s; :}
    ;

DecList ::= Dec:d
    {: RESULT = new Absyn.DecList(d,null); :}
    | Dec:d DecList:ds
    {: RESULT = new Absyn.DecList(d,ds); :}
    ;
    
Dec   ::= error
    | FunctionDec:f
    {: RESULT = f;:}
    | VAR:va ID:id NameType:nt ASSIGN Exp:e
    {: RESULT = new Absyn.VarDec(valeft,sym(id),nt,e); :}
    | TypeDec:t
    {: RESULT = t; :}
    ;

FunctionDec ::= 
    FUNCTION:fu ID:id LPAREN Fields:fld RPAREN NameType:Nt EQ Exp:e OptFunctions:f
    {: RESULT = new Absyn.FunctionDec(fuleft,sym(id),fld,Nt,e,f); :}
    ;
    
OptFunctions ::=
    
    | FunctionDec:fu
    {: RESULT = fu; :}
    ;


Fields ::= 
    error
    |
    | ID:id1 COLON:col ID:id2 OptFields:fld
    {: RESULT = new Absyn.FieldList(colleft,sym(id1),sym(id2),fld); :}
    ;
    
OptFields ::= 
    error
    |
    | COMMA:com ID:id1 COLON ID:id2 OptFields:fld
    {: RESULT = new Absyn.FieldList(comleft,sym(id1),sym(id2),fld); :}
    ;
    
NameType ::= 
    error
    |
    | COLON:co ID:id
    {:RESULT = new Absyn.NameTy(coleft,sym(id)); :}
    ;

TypeDec ::= 
    TYPE:ty1 ID:id EQ:eq Type:ty2 OptTypes:ty3
    {:RESULT = new Absyn.TypeDec(ty1left,sym(id),ty2,ty3); :}
    ;

OptTypes ::=

    | TypeDec:ty
    {: RESULT = ty; :} 
    ;
  
Type ::=  
    ID:id
    {:RESULT = new Absyn.NameTy(idleft,sym(id)); :} 
    | LBRACE:lbrace Fields:fld RBRACE
    {: RESULT = new Absyn.RecordTy(lbraceleft,fld); :}
    | ARRAY:arr OF ID:id
    {: RESULT = new Absyn.ArrayTy(arrleft,sym(id)); :}
    ;