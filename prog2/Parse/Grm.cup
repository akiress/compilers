package Parse;

action code {:
  // chamada do pretty-printer
  // public Absyn.Print p = new Absyn.Print(System.out);

  static Symbol.Symbol sym(String s) {
    return Symbol.Symbol.symbol(s);
  }
:};

parser code  {: 
  public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
         java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String ID, STRING;
terminal Integer INT;
terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN, 
  LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
  TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
  ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
  LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE;
  
non terminal Absyn.Exp          exp;
non terminal Absyn.Var          var;
non terminal Absyn.ExpList      expList;
non terminal Absyn.FieldVar     fieldVar;
non terminal Absyn.SubscriptVar subscriptVar;
non terminal Absyn.TypeDec      typeDec,optTypes;
non terminal Absyn.FunctionDec  functionDec, optFunctions;
non terminal Absyn.Dec          dec;
non terminal Absyn.DecList      decList;
non terminal Absyn.Ty           type;
non terminal Absyn.NameTy       nameType;
non terminal Absyn.ExpList      arguments, optArguments, sequence, seqTail;
non terminal Absyn.FieldList    fields, optFields;
non terminal Absyn.FieldExpList fieldExps, optFieldExps;
non terminal empty; 

precedence nonassoc THEN;
precedence nonassoc ELSE;
precedence nonassoc ASSIGN;
precedence left     OR;
precedence left     AND;
precedence nonassoc EQ, NEQ, LT, LE, GT, GE;
precedence left     PLUS, MINUS;
precedence left     TIMES, DIVIDE;

start with exp;

exp   ::= error:e
    {: RESULT = new Absyn.SeqExp(eleft, null); :}
    | var:v
    {: RESULT = new Absyn.VarExp(vleft, v); :}
    | NIL:nil
    {: RESULT = new Absyn.NilExp(nilleft); :}
    | INT:i
    {:RESULT = new Absyn.IntExp(ileft,i.intValue()); :}
    | STRING: s
    {:RESULT = new Absyn.StringExp(sleft, (String)(s)); :}
    | ID:f LPAREN:lp arguments:args RPAREN
    {:RESULT = new Absyn.CallExp(lpleft, sym(f), args); :}
    | exp:e1 AND:op exp:e2
    {:RESULT = new Absyn.IfExp(opleft,e1,e2,new Absyn.IntExp(opleft,0)); :} 
    | exp:e1 OR:op exp:e2
    {:RESULT = new Absyn.IfExp(opleft,e1,new Absyn.IntExp(opleft,1),e2); :}
    | exp:e1 PLUS:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,0,e2); :} 
    | exp:e1 MINUS:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,1,e2); :} 
    | exp:e1 TIMES:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,2,e2); :} 
    | exp:e1 DIVIDE:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,3,e2); :} 
    | exp:e1 EQ:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,4,e2); :} 
    | exp:e1 NEQ:op exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,5,e2); :} 
    | exp:e1 LT:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,6,e2); :} 
    | exp:e1 LE:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,7,e2); :} 
    | exp:e1 GT:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,8,e2); :} 
    | exp:e1 GE:op  exp:e2
    {:RESULT = new Absyn.OpExp(opleft,e1,9,e2); :} 
    | MINUS:op exp:e
    {:RESULT = new Absyn.OpExp(opleft,new Absyn.IntExp(opleft,0),1,e); :}
    | ID:type_id LBRACE:lbrace fieldExps:fld RBRACE
    {:RESULT = new Absyn.RecordExp(lbraceleft, sym(type_id), fld); :}
    | var:v ASSIGN:ass exp:e
    {:RESULT = new Absyn.AssignExp(assleft,v,e);:}  
    | IF exp:e1 THEN:the exp:e2
    {:RESULT = new Absyn.IfExp(theleft,e1,e2);:}      
    | IF:i exp:e1 THEN exp:e2 ELSE exp:e3
    {:RESULT = new Absyn.IfExp(ileft,e1,e2,e3);:}
    | WHILE:w exp:e1 DO exp:e2
    {: RESULT = new Absyn.WhileExp(wleft, e1, e2); :}
    | FOR:f ID:id ASSIGN:ass exp:e1 TO exp:e2 DO exp:e3
    {: RESULT = new Absyn.ForExp(fleft, new Absyn.VarDec(assleft, sym(id), null, e1), e2, e3);:} 
    | BREAK:b
    {: RESULT = new Absyn.BreakExp(bleft); :}
    | LET decList:decs IN:in expList:ex END
    {: RESULT = new Absyn.LetExp(inleft, decs,new Absyn.SeqExp(exleft,ex)); :}
    | ID:id LBRACK:lbrack exp:e1 RBRACK OF exp:e2
    {: RESULT = new Absyn.ArrayExp(lbrackleft, sym(id),e1,e2);:}
    | LPAREN:lp expList:es RPAREN
    {: RESULT = new Absyn.SeqExp(lpleft,es); :}
    ;

expList ::= empty
    |   exp:e
    {:RESULT = new Absyn.ExpList(e,null);:}
    |   sequence:seq
    {:RESULT = seq;:}
    ;
    
var ::= ID:id
    {: RESULT = new Absyn.SimpleVar(idleft, sym(id)); :}
    | fieldVar:fl
    {: RESULT = fl; :}
    | subscriptVar:sub
    {: RESULT = sub; :}
    ;
    
fieldVar ::= var:n 
    DOT:s ID:id
    {: RESULT = new Absyn.FieldVar(sleft,n,sym(id)); :}
    ;
    
subscriptVar ::= ID:id
    LBRACK:lbrack exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,new Absyn.SimpleVar(idleft,sym(id)),e); :}
    | fieldVar:fl LBRACK:lbrack exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,fl,e); :}
    | subscriptVar:sub LBRACK:lbrack exp:e RBRACK
    {: RESULT = new Absyn.SubscriptVar(lbrackleft,sub,e); :}
    ;   

arguments ::=
    | exp:e optArguments:args
    {: RESULT = new Absyn.ExpList(e,args); :} 
    ;

optArguments ::= error
    |
    {: RESULT = null; :}
    | COMMA exp:e optArguments:args
    {: RESULT = new Absyn.ExpList(e,args); :}
    ;

fieldExps ::= error
    |
    | ID:id EQ:eq exp:e optFieldExps:fld
    {: RESULT = new Absyn.FieldExpList(eqleft,sym(id),e,fld); :}
    ;
    
optFieldExps ::= error
    |
    | COMMA:com ID:id EQ exp:e optFieldExps:fld
    {: RESULT = new Absyn.FieldExpList(comleft,sym(id),e,fld); :}
    ;

empty ::= ;

sequence ::= exp:e SEMICOLON seqTail:s
    {: RESULT = new Absyn.ExpList(e,s); :}
    ;

seqTail ::= exp:e
    {: RESULT = new Absyn.ExpList(e,null); :}
    | sequence:s
    {: RESULT = s; :}
    ;

decList ::= dec:d
    {: RESULT = new Absyn.DecList(d,null); :}
    | dec:d decList:ds
    {: RESULT = new Absyn.DecList(d,ds); :}
    ;
    
dec   ::= error
    | functionDec:f
    {: RESULT = f;:}
    | VAR:va ID:id nameType:nt ASSIGN exp:e
    {: RESULT = new Absyn.VarDec(valeft,sym(id),nt,e); :}
    | typeDec:t
    {: RESULT = t; :}
    ;

functionDec ::= 
    FUNCTION:fu ID:id LPAREN fields:fld RPAREN nameType:Nt EQ exp:e optFunctions:f
    {: RESULT = new Absyn.FunctionDec(fuleft,sym(id),fld,Nt,e,f); :}
    ;
    
optFunctions ::=
    
    | functionDec:fu
    {: RESULT = fu; :}
    ;


fields ::= 
    error
    |
    | ID:id1 COLON:col ID:id2 optFields:fld
    {: RESULT = new Absyn.FieldList(colleft,sym(id1),sym(id2),fld); :}
    ;
    
optFields ::= 
    error
    |
    | COMMA:com ID:id1 COLON ID:id2 optFields:fld
    {: RESULT = new Absyn.FieldList(comleft,sym(id1),sym(id2),fld); :}
    ;
    
nameType ::= 
    error
    |
    | COLON:co ID:id
    {:RESULT = new Absyn.NameTy(coleft,sym(id)); :}
    ;

typeDec ::= 
    TYPE:ty1 ID:id EQ:eq type:ty2 optTypes:ty3
    {:RESULT = new Absyn.TypeDec(ty1left,sym(id),ty2,ty3); :}
    ;

optTypes ::=

    | typeDec:ty
    {: RESULT = ty; :} 
    ;
  
type ::=  
    ID:id
    {:RESULT = new Absyn.NameTy(idleft,sym(id)); :} 
    | LBRACE:lbrace fields:fld RBRACE
    {: RESULT = new Absyn.RecordTy(lbraceleft,fld); :}
    | ARRAY:arr OF ID:id
    {: RESULT = new Absyn.ArrayTy(arrleft,sym(id)); :}
    ;